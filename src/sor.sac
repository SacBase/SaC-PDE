/**
 * This solves
 *  u_xx + u_yy = f
 * on Omega = [0, 1] x [0, 1]
 * with Dirichlet boundary conditions, e.g. u = g on the boundary of Omega.
 *
 * The technique uses a Gauss-Seidel update with successive overrelaxation.
 **/

use StdIO: all;
use Math: all;
use Array: all;

double L2(double[d:shp] x)
{
  return sqrt(sum(x * x) / prod(tod(shp)));
}

inline
double[n, n] sor(double[n, n] u, double h, double[n, n] f)
{
  pi    = 4d * atan(1d);
  omega = 2d / (1d + sin(pi * h));

  for (i = 1; i < n - 1; i++) {
    for (j = 1; j < n - 1; j++) {
      u[i, j] = omega / 4d * (u[i - 1, j    ] +
                              u[i + 1, j    ] +
                              u[i    , j - 1] +
                              u[i    , j + 1] -
                              h * h * f[i, j]) +
                  (1d - omega) * u[i, j];
    }
  }
  return u;
}

int main()
{
  a = 1d;
  b = 2d;
  n = 2048;
  h = (b - a) / tod(n + 1);

  f = {[i, j] -> 1.25 * exp(tod(i) * h + tod(j) * h / 2d)
              | [i, j] < [n, n]};
  utrue = {[i, j] -> exp(tod(i) * h + tod(j) * h / 2d)
              | [i, j] < [n, n]};
  u = {[i, j] -> 0d | [i, j] < [n, n]};

  /* Set boundary conditions */
  for (i = 0; i < n; i++) {
    u[0    , i]     = utrue[0    , i];
    u[n - 1, i]     = utrue[n - 1, i];
    u[i, 0    ]     = utrue[i    , 0    ];
    u[i, n - 1]     = utrue[i    , n - 1];
  }

  i = 0;
  error = 1e308;
  while (error > 1e-6) {
    u = sor(u, h, f);
    if (i % 100 == 0) {
      error = L2(u - utrue) / L2(utrue);
      printf("Iter %d: relative error is %e\n", i, error);
    }
    i++;
  }

  return 0;
}
