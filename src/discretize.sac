/**
 * The Laplacian of a smooth function u: R x R -> R is defined as
 *   u_xx + u_yy
 * where u_xx means taking the partial derivative with respect to x twice,
 * and similar for y.
 * 
 * Example:
 * Let u(x, y) = exp(x + y / 2)
 * Then 
 *     u_x    = exp(x + y / 2), u_xx = exp(x + y / 2)
 *     u_y    = 0.5 exp(x + y / 2), u_yy = 0.25 exp(x + y / 2)
 * Laplacian u = 1.25 exp(x + y / 2)
 *
 * We can approximate functions R x R -> R on a square grid [a, b] x [a, b]
 * by computing points at (a + i * h, b + j * h) for h = (b - a) / (n + 1).
 *
 * We can approximate the Laplacian by a linear function called the five-point
 * stencil. The error between the Laplacian and five-point stencil is
 * O(h^2). This is called the truncation error.
 *
 * Note on numeric stability:
 *   The derivative of u in x is
 *     lim_{h -> 0} (u(x - h) - u(x + h)) / (2h)
 *   We do not know the true value of u(x - h) or u(x + h), but instead have
 *   a computed value that is slightly wrong. That means we get catastrophic
 *   cancellation for u(x - h) close to u(x + h), which is bound to happen
 *   for small h. For this reason we should not take h too small.
 **/

use StdIO: all;
use Math: all;
use Array: all;

inline
double[d:shp] stencil(double[d:shp] x, double[d:wshp] w)
{
  return {iv -> sum({jv -> w[jv] * x[iv + jv - wshp / 2]})
             | wshp / 2 <= iv < shp - wshp / 2;
          iv -> x[iv]};
}

double L2(double[d:shp] x)
{
  return sqrt(sum(x * x) / prod(tod(shp)));
}

double[n, n] five_point(double[n, n] U, double h)
{
  return stencil(U, [[0d,  1d, 0d],
                     [1d, -4d, 1d],
                     [0d,  1d, 0d]]) / (h * h);
}

int main()
{
  a = 1d;
  b = 2d;

  for (n = 8; n <= 16 * 1024; n *= 2) {
      h = (b - a) / tod(n + 1);
      u = {[i, j] -> exp(tod(i) * h + tod(j) * h / 2d) | [i, j] < [n, n]};
      laplace_u = 1.25 * u;
      laplace_u_approx = five_point(u, h);
      /* Assume we know values on boundary */
      for (i = 0; i < n; i++) {
        laplace_u_approx[0    , i    ] = laplace_u[0    , i    ];
        laplace_u_approx[n - 1, i    ] = laplace_u[n - 1, i    ];
        laplace_u_approx[i    , 0    ] = laplace_u[i    , 0    ];
        laplace_u_approx[i    , n - 1] = laplace_u[i    , n - 1];
      }
      printf("n = %8d, relative error: %e\n",
             n, L2(laplace_u_approx - laplace_u) / L2(laplace_u));
  }

  return 0;
}
