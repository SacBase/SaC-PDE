/**
 * The Laplacian of a smooth function u: R x R -> R is defined as
 *   u_xx + u_yy
 * where u_xx means taking the partial derivative with respect to x twice,
 * and similar for y.
 * 
 * Example:
 * Let u(x, y) = sin(x) + sin(y)
 * Then 
 *     u_x    = cos(x), u_xx = -sin(x)
 *     u_y    = cos(y), u_yy = -sin(y)
 * Laplacian u = -sin(x) - sin(y).
 *
 * We can approximate functions R x R -> R on a square grid [0, a] x [0, a]
 * by computing points at (i * h, j * h) for h = 0, ..., a / n.
 *
 * We can approximate the Laplacian by a linear function called the five-point
 * stencil. The error between the Laplacian and five-point stencil is
 * O(h^2). This is called the truncation error.
 *
 * Note on numeric stability:
 *   The derivative of u in x is
 *     lim_{h -> 0} (u(x - h) - u(x + h)) / (2h)
 *   We do not know the true value of u(x - h) or u(x + h), but instead have
 *   a computed value that is slightly wrong. That means we get catastrophic
 *   cancellation for u(x - h) close to u(x + h), which is bound to happen
 *   for small h. For this reason we should not take h too small. A good
 *   balance between the truncation error and this instability is to take
 *   h around the square root of the machine precision (2^{-53} for double,
 *   2^{-24} for float).
 **/

use StdIO: all;
use Math: all;
use Array: all;

inline
double[d:shp] stencil(double[d:shp] x, double[d:wshp] w)
{
  return {iv -> sum({jv -> w[jv] * x[mod(iv + jv - wshp / 2, shp)]})
             | iv < shp};
}

double L2(double[d:shp] x)
{
  return sqrt(sum(x * x) / prod(tod(shp)));
}

double l_inf(double[d:shp] x)
{
  return with {
      (0 * shp <= iv < shp): abs(x[iv]);
  }: fold(max, 0d);
}

double[n, n] five_point(double[n, n] U, double h)
{
  return stencil(U, [[0d,  1d, 0d],
                     [1d, -4d, 1d],
                     [0d,  1d, 0d]]) / (h * h);
}

int main()
{
  for (n = 64; n <= 16 * 1024; n *= 2) {
      two_pi = 8d * atan(1d);
      h      = two_pi / tod(n);
#if 0
      /* Incorrect around boundaries */
      U = {[i, j] -> exp(tod(i) * h + tod(i) * h / 2d) | [i, j] < [n, n]};
      Laplace_U = 1.25 * U;
#else
      U = {[i, j] -> sin(tod(i) * h) +
                     sin(tod(j) * h)
                  | [i, j] < [n, n]};
      Laplace_U = -U;
#endif
      printf("n = %8d, relative error: %e\n",
             n,
             L2(five_point(U, h) - Laplace_U) / L2(five_point(Laplace_U, h)));
  }

  return 0;
}
