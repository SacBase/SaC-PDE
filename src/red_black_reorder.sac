/**
 * Shows how to reorder the equations of the discretization to get red-black
 * ordering. Puts the even equations at the top, and odd at the bottom. We
 * can see this as an isomorphism 
 *
 * R^(n / 2) \oplus R^(n / 2) =
 * R^(n) =
 * R^(n / 2) \oplus R^(n / 2)
 * 
 * where the first corresponds to a cyclic distribution over two processors,
 * and the second one to a block distribution. We do this for both the domain
 * (columns) and range (rows).
 **/

use Array: all;
use StdIO: all;

int main()
{
  n = 10;
  A = {iv -> 0 | iv < [n, n]};
  for (i = 0; i < n; i++) {
    A[i, i] = -2;
    A[i, mod(i + 1, n)] = 1;
    A[i, mod(i - 1, n)] = 1;
  }
  
  printf("Discretization with natural order:\n");
  print(A);

  A_rb = reshape([n / 2, 2, n], A);
  A_rb = {[i, j, k] -> A_rb[j, i, k] | [i, j, k] < [2, n / 2, n]};
  A_rb = reshape([n, n], A_rb);
  printf("Block-cyclic redistribution rows\n");
  print(A_rb);

  A_rb = transpose(A_rb);
  A_rb = reshape([n / 2, 2, n], A_rb);
  A_rb = {[i, j, k] -> A_rb[j, i, k] | [i, j, k] < [2, n / 2, n]};
  A_rb = reshape([n, n], A_rb);
  A_rb = transpose(A_rb);
  printf("Block-cyclic redistribution columns (red-black)\n");
  print(A_rb);

  printf("We can see A as a block matrix -2I  B\n");
  printf("                               B^t  -2I\n\n");
  printf("for B =\n");

  print(tile([n / 2, n / 2], [0, n / 2], A_rb));

  return 0;
}
