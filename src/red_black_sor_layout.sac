/**
 * This solves
 *  u_xx + u_yy = f
 * on Omega = [0, 1] x [0, 1]
 * with Dirichlet boundary conditions, e.g. u = g on the boundary of Omega.
 *
 * The technique uses a Gauss-Seidel update with successive overrelaxation.
 * We use red-black ordering so we can parallelise it. This is not exactly the 
 * same as the sequential Gauss-Seidel, but the convergence is similar.
 * We change the ordering to make the code prettier, and so the cache-behaviour
 * and vectorization is better.
 **/

use StdIO: all;
use Math: all;
use Array: all;
inline
double[d:shp] stencil(double[d:shp] x, double[d:wshp] w)
{
  return {iv -> sum({jv -> w[jv] * x[mod(iv + jv - wshp / 2, shp)]})
             | iv < shp};
}

double L2(double[d:shp] x)
{
  return sqrt(sum(x * x) / prod(tod(shp)));
}

double L2_rb(double[d:shp] x, double[d:shp] y)
{
  return sqrt((sum(x * x) + sum(y * y)) / (2d * prod(tod(shp))));
}

double l_inf(double[d:shp] x)
{
  return with {
      (0 * shp <= iv < shp): abs(x[iv]);
  }: fold(max, 0d);
}

inline
double[n, m], double[n, m] to_red_black(double[n, n] x)
{
  black = {[i, j] -> x[i, 2 * j    ] 
                   | [0, 0] <= [i, j] < [n, n / 2] step [2, 1];
           [i, j] -> x[i, 2 * j + 1] 
                   | [1, 0] <= [i, j] < [n, n / 2] step [2, 1]};
  red = {[i, j] -> x[i, 2 * j + 1] 
                 | [0, 0] <= [i, j] < [n, n / 2] step [2, 1];
         [i, j] -> x[i, 2 * j    ] 
                 | [1, 0] <= [i, j] < [n, n / 2] step [2, 1]};

  return (red, black);
}

inline 
double[n, n] from_red_black(double[n, m] red, double[n, m] black)
{
  x = {[i, j] -> black[i, j / 2]
              | [0, 0] <= [i, j] < [n, n] step [2, 2];
       [i, j] -> black[i, j / 2]
              | [1, 1] <= [i, j] < [n, n] step [2, 2];
       [i, j] -> red[i, j / 2]
              | [0, 1] <= [i, j] < [n, n] step [2, 2];
       [i, j] -> red[i, j / 2]
              | [1, 0] <= [i, j] < [n, n] step [2, 2]};
  return x;
}

inline
double[n, m], double[n, m] sor(double[n, m] u_red, double[n, m] u_black,
                               double[n, m] f_red, double[n, m] f_black,
                               double h)
  | (n == 2 * m && m % 2 == 0)
{
  pi     = 4d * atan(1d);
  omega = 2d / (1d + sin(pi * h));

  u_black = {[i, j] -> omega / 4d * (u_red[i - 1, j    ] + 
                                     u_red[i    , j    ] +
                                     u_red[i    , j + 1] +
                                     u_red[i + 1, j    ] -
                                     h * h * f_black[i, j]) +
                       (1d - omega) * u_black[i, j]
                    | [1, 0] <= [i, j] < [n - 1, m - 1] step [2, 1];
             [i, j] -> omega / 4d * (u_red[i - 1, j    ] +
                                     u_red[i    , j - 1] +
                                     u_red[i    , j    ] +
                                     u_red[i + 1, j    ] -
                                     h * h * f_black[i, j]) +
                       (1d - omega) * u_black[i, j]
                    | [2, 1] <= [i, j] < [n - 1, m    ] step [2, 1];
             [i, j] -> u_black[i, j] | [0, 0] <= [i, j] < [n, m]};

  u_red = {[i, j] -> omega / 4d * (u_black[i - 1, j    ] + 
                                   u_black[i    , j - 1] +
                                   u_black[i    , j    ] +
                                   u_black[i + 1, j    ] -
                                   h * h * f_red[i, j]) +
                     (1d - omega) * u_red[i, j]
                  | [1, 1] <= [i, j] < [n - 1, m] step [2, 1];
           [i, j] -> omega / 4d * (u_black[i - 1, j    ] + 
                                   u_black[i    , j    ] +
                                   u_black[i    , j + 1] +
                                   u_black[i + 1, j    ] -
                                   h * h * f_red[i, j]) +
                                  (1d - omega) * u_red[i, j]
                  | [2, 0] <= [i, j] < [n - 1, m - 1] step [2, 1];
           [i, j] -> u_red[i, j] | [0, 0] <= [i, j] < [n, m]};

  return (u_red, u_black);
}

int main()
{
  n      = 2048;
  pi     = 4d * atan(1d);
  two_pi = 8d * atan(1d);
  h      = 1d / tod(n + 1);
  omega  = 2d / (1d + sin(pi * h));

  f = {[i, j] -> 1.25 * exp(tod(i) * h + tod(j) * h / 2d)
              | [i, j] < [n, n]};
  utrue = {[i, j] -> exp(tod(i) * h + tod(j) * h / 2d)
              | [i, j] < [n, n]};
  u = {[i, j] -> 0d | [i, j] < [n, n]};

  for (i = 0; i < n; i++) {
    u[0    , i]     = utrue[0    , i];
    u[n - 1, i]     = utrue[n - 1, i];
    u[i, 0    ]     = utrue[i    , 0    ];
    u[i, n - 1]     = utrue[i    , n - 1];
  }

  u_red, u_black = to_red_black(u);
  f_red, f_black = to_red_black(f);
  utrue_red, utrue_black = to_red_black(utrue);
  u_red, u_black = sor(u_red, u_black, f_red, f_black, h);

  i = 0;
  error = 1e308;
  while (error > 1e-6)
  {
    u_red, u_black = sor(u_red, u_black, f_red, f_black, h);
    if (i % 100 == 0) {
      error = L2_rb(u_red - utrue_red, u_black - utrue_black) / 
              L2_rb(utrue_red, utrue_black);
      printf("Iter %d: relative error is %e\n", 
              i, error);
    }
    i++;
  }

  return 0;
}
